---
title: Testing
sidebar_position: 120
---

Automating the testing of your Convex functions is easy.

## Get Started

<StepByStep>

  <Step title="Install test dependencies">
    Install [Vitest](https://vitest.dev/) and the [`convex-test`](https://www.npmjs.com/package/convex-test) library.

    ```sh
    npm install --save-dev vitest convex-test
    ```

  </Step>

  <Step title="Setup NPM scripts">
    
    Add these scripts to your `package.json`

    ```json title="package.json"
    "scripts": {
      "test": "vitest",
      "test:once": "vitest run",
      "test:debug": "vitest --inspect-brk --no-file-parallelism"
    }
    ```

  </Step>

  <Step title="Add a test file">
    
    In your `convex` folder add a file ending in <JSDialectFileName name=".test.ts" />

    The example test calls the `api.messages.send` mutation twice
    and then asserts that the `api.messages.list` query returns
    the expected results.

    ```ts title="convex/messages.test.ts"
    import { convexTest } from "convex-test";
    import { expect, test } from "vitest";
    import { api } from "./_generated/api";
    import schema from "./schema";

    test("sending messages", async () => {
      const t = convexTest(schema);
      await t.mutation(api.messages.send, { body: "Hi!", author: "Sarah" });
      await t.mutation(api.messages.send, { body: "Hey!", author: "Tom" });
      const messages = await t.query(api.messages.list);
      expect(messages).toMatchObject([
        { body: "Hi!", author: "Sarah" },
        { body: "Hey!", author: "Tom" }
      ]);
    });
    ```

  </Step>

  <Step title="Run tests">

    Start the tests with `npm run test`. When you change the test file the tests will rerun
    automatically.

    You might need to hit `Enter` or the `R` key to rerun the tests when
    you change your functions.

    ```sh
    npm run test
    ```

  </Step>

</StepByStep>

If you're not familiar with Vitest or Jest read the
[Vitest Getting Started docs](https://vitest.dev/guide) first.

## `convex-test` library

The `convex-test` library provides a community-maintained mock implementation of
the Convex backend in TypeScript.

The library includes a
[test suite](https://github.com/get-convex/convex-test/tree/main/convex) which
you can browse to see examples of using it.

### `convexTest`

The library exports a `convexTest` function which should be called at the start
of each of your tests. The function returns an object which is by convention
stored in the `t` variable and which provides methods for exercising your Convex
functions.

If your project uses a [schema](/docs/database/schemas.mdx) you should pass it
to the `convexTest` function:

```ts title="convex/myFunctions.test.ts"
import { convexTest } from "convex-test";
import { test } from "vitest";
import schema from "./schema";

test("some behavior", async () => {
  const t = convexTest(schema);
  // use `t`...
});
```

Passing in the schema is required for the tests to correctly implement schema
validation and for correct typing of
[`t.run`](#setting-up-and-inspecting-data-and-storage-with-trun).

If you don't have a schema, call `convexTest()` with no argument.

### Calling functions with `t.query`, `t.mutation` and `t.action`

Your test can call public and internal Convex [functions](/docs/functions.mdx)
in your project:

```ts title="convex/myFunctions.test.ts"
import { convexTest } from "convex-test";
import { test } from "vitest";
import { api, internal } from "./_generated/api";

test("functions", async () => {
  const t = convexTest();
  const x = await t.query(api.myFunctions.myQuery, { a: 1, b: 2 });
  const y = await t.query(internal.myFunctions.internalQuery, { a: 1, b: 2 });
  const z = await t.mutation(api.myFunctions.mutateSomething, { a: 1, b: 2 });
  const w = await t.mutation(internal.myFunctions.mutateSomething, { a: 1 });
  const u = await t.action(api.myFunctions.doSomething, { a: 1, b: 2 });
  const v = await t.action(internal.myFunctions.internalAction, { a: 1, b: 2 });
});
```

### Setting up and inspecting data and storage with `t.run`

Sometimes you might want to directly [write](/docs/database/writing-data.mdx) to
the mock database or [file storage](/docs/file-storage.mdx) from your test,
without needing a declared function in your project. You can use the `t.run`
method which takes a handler that is given a `ctx` that allows reading from and
writing to the mock backend:

```ts title="convex/tasks.test.ts"
import { convexTest } from "convex-test";
import { expect, test } from "vitest";
import { api, internal } from "./_generated/api";

test("functions", async () => {
  const t = convexTest();
  const firstTask = await t.run(async (ctx) => {
    await ctx.db.insert("tasks", { text: "Eat breakfast" });
    return await ctx.db.query("tasks").first();
  });
  expect(firstTask).toMatchObject({ text: "Eat breakfast" });
});
```

### Testing scheduled functions

One advantage of using a mock implementation running purely in JavaScript is
that you can control time in the Vitest test environment. To test
implementations relying on
[scheduled functions](/docs/scheduling/scheduled-functions.mdx) use
[Vitest's fake timers](https://vitest.dev/guide/mocking.html#timers) in
combination with `t.finishInProgressScheduledFunctions`:

```ts title="scheduling.test.ts"
import { convexTest } from "convex-test";
import { expect, test, vi } from "vitest";
import { api, internal } from "./_generated/api";
import schema from "./schema";

test("mutation scheduling action", async () => {
  // Enable fake timers
  vi.useFakeTimers();

  const t = convexTest(schema);

  // Call a function that schedules a mutation or action
  const scheduledFunctionId = await t.mutation(
    api.scheduler.mutationSchedulingAction,
    { delayMs: 10000 },
  );

  // Advance the mocked time
  vi.advanceTimersByTime(5000);

  // Advance the mocked time past the scheduled time of the function
  vi.advanceTimersByTime(6000);

  // Or run all currently pending timers
  vi.runAllTimers();

  // At this point the scheduled function will be `inProgress`,
  // now wait for it to finish:
  await t.finishInProgressScheduledFunctions();

  // Assert that the scheduled function succeeded or failed
  const scheduledFunctionStatus = t.run(async (ctx) => {
    return ctx.db.get(scheduledFunctionId);
  });
  expect(scheduledFunctionStatus).toMatchObject({ state: { kind: "success" } });

  // Reset to normal `setTimeout` etc. implementation
  vi.useRealTimers();
});
```

Check out more examples in
[this file](https://github.com/get-convex/convex-test/blob/main/convex/scheduler.test.ts).

### Testing authentication with `t.withIdentity`

To test functions which depend on the current [authenticated](/docs/auth.mdx)
user identity you can create a version of the `t` accessor with given
[user identity attributes](/api/interfaces/server.UserIdentity). If you don't
provide them, `issuer`, `subject` and `tokenIdentifier` will be generated
automatically:

```ts title="tasks.test.ts"
import { convexTest } from "convex-test";
import { expect, test } from "vitest";
import { api } from "./_generated/api";
import schema from "./schema";

test("authenticated functions", async () => {
  const t = convexTest(schema);

  const asSarah = t.withIdentity({ name: "Sarah" });
  await asSarah.mutation(api.tasks.create, { text: "Add tests" });

  const sarahsTasks = await asSarah.query(api.tasks.list);
  expect(sarahsTasks).toMatchObject([{ text: "Add tests" }]);

  const asLee = t.withIdentity({ name: "Lee" });
  const leesTasks = await asLee.query(api.tasks.list);
  expect(leesTasks).toEqual([]);
});
```

### Mocking `fetch` calls

You can use Vitest's
[vi.stubGlobal](https://vitest.dev/guide/mocking.html#globals) method:

```ts title="ai.test.ts"
import { expect, test, vi } from "vitest";
import { convexTest } from "../index";
import { api } from "./_generated/api";
import schema from "./schema";

test("ai", async () => {
  const t = convexTest(schema);

  vi.stubGlobal(
    "fetch",
    vi.fn(async () => ({ text: async () => "I am the overlord" }) as Response),
  );

  const reply = await t.action(api.messages.sendAIMessage, { prompt: "hello" });
  expect(reply).toEqual("I am the overlord");

  vi.unstubAllGlobals();
});
```

### Asserting results

See Vitest's [Expect](https://vitest.dev/api/expect.html) reference.

[`toMatchObject()`](https://vitest.dev/api/expect.html#tomatchobject) is
particularly helpful when asserting the shape of results without needing to list
every object field.

### Debugging tests

You can attach a debugger to the running tests. Read the Vitest
[Debugging docs](https://vitest.dev/guide/debugging.html) and then use
`npm run test:debug`.

### Limitations

Since `convex-test` is only a mock implementation, it doesn't have many of the
behaviors of the real Convex backend. Still, it should be helpful for testing
the logic in your functions, and catching regressions caused by changes to your
code.

Some of the ways the mock differs:

1. Error messages content. You should not write product logic that relies on the
   content of error messages thrown by the real backend, as they are always
   subject to change.
2. Limits. The mock doesn't enforce size and time
   [limits](/docs/production/state/limits.mdx).
3. ID format. Your code should not depend on the document ID format.
4. Runtime built-ins. Most of your functions are written for the
   [Convex default runtime](/docs/functions/runtimes.mdx), while Vitest runs
   your tests in your local Node.js runtime. You should always test new code
   manually to make sure it doesn't use built-ins not available in the Convex
   runtime.

## Testing using the local backend

Alternatively to `convex-test` you can test your functions using the open-source
version of Convex backend. Follow
[this guide](https://stack.convex.dev/testing-with-local-oss-backend) for the
instructions.

Note that testing against the local backend has its advantages but it also has
some drawbacks:

1. It requires setting up the local backend, which is more involved.
1. No control over time and any scheduled functions will run as scheduled.
1. Crons will also run unless disabled via `IS_TEST`.
1. No way to mock `fetch` calls.
1. No way to mock dependencies or parts of the codebase.
1. No way to control randomness (tests may not be deterministic).
1. No way to set environment variable values from within tests.

{/* todo: testing against preview deployments */}
